"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var ReactComponents_exporter;
(self["webpackChunkReactComponents_"] = self["webpackChunkReactComponents_"] || []).push([["exporter"],{

/***/ "./Yesplan/resources/reactjs-components/exporter.js":
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _common_convertDataviewValueToExcel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./Yesplan/resources/reactjs-components/common/convertDataviewValueToExcel.ts\");\n/* harmony import */ var _common_convertDataviewValueToExcel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_common_convertDataviewValueToExcel__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/* eslint-disable camelcase, func-names, no-bitwise, no-loop-func, no-unused-vars, no-var, object-shorthand, prefer-template, vars-on-top -- TODO: drop these disablements (added as a provision for \"grandfathered\" code that was previously included through gulp) */\n\n\nvar $exporter = function () {\n  /* Generate an xlsx file\n    The configuration object:\n    url             : data source\n    headers         : array of arrays (one for each header) with header names (strings)\n    widths          : array of column widths (integers)\n    exportname      : file name\n    exportsheetname : sheet name\n    exceldateformats: object with Excel format string for 'date' and 'datetime'\n    on_finished     : function to be invoked when the generation has completed */\n  function make_xlsx(configuration) {\n    function sheet_from_array_of_arrays(headers, bodyData) {\n      var data = headers.concat(bodyData);\n      var ws = {};\n      for (var R = 0; R !== data.length; ++R) {\n        for (var C = 0; C !== data[R].length; ++C) {\n          _common_convertDataviewValueToExcel__WEBPACK_IMPORTED_MODULE_0___default()(data[R][C], null, function (excelCellValue, excelNumberFormat) {\n            var cell = {};\n            if (excelCellValue !== '') {\n              cell.t = function () {\n                cell.v = excelCellValue;\n                switch (_typeof(excelCellValue)) {\n                  case 'number':\n                    return 'n';\n                  case 'boolean':\n                    return 'b';\n                  case 'string':\n                    return 's';\n                  default:\n                    throw new Error(\"Unexpected case for 'excelCellValue'\");\n                }\n              }();\n            }\n            if (excelNumberFormat) cell.z = excelNumberFormat;\n            // Apply specific format to the header row\n            if (R === 0) {\n              cell.s = {\n                fill: {\n                  fgColor: {\n                    rgb: '00FFCC00'\n                  }\n                },\n                font: {\n                  bold: true\n                }\n              };\n            }\n            var cell_ref = XLSX.utils.encode_cell({\n              c: C,\n              r: R\n            });\n            ws[cell_ref] = cell;\n          });\n        }\n      }\n      var range = {\n        s: {\n          c: 0,\n          r: 0\n        },\n        e: {\n          c: headers[0].length - 1,\n          r: data.length - 1\n        }\n      };\n      ws['!ref'] = XLSX.utils.encode_range(range);\n      return ws;\n    }\n    $.getJSON(configuration.url).done(function (data) {\n      var ws_name = configuration.exportsheetname;\n      function Workbook() {\n        if (!(this instanceof Workbook)) return new Workbook();\n        this.SheetNames = [];\n        this.Sheets = {};\n      }\n      var wb = new Workbook();\n      var ws = sheet_from_array_of_arrays(configuration.headers, data);\n      var defaultCellStyle = {\n        font: {\n          name: 'Calibri',\n          sz: 11,\n          color: 'FF00FF88'\n        },\n        fill: {\n          fgColor: {\n            rgb: 'FFFFAA00'\n          }\n        }\n      };\n      var wopts = {\n        bookType: 'xlsx',\n        bookSST: false,\n        type: 'binary',\n        defaultCellStyle: defaultCellStyle,\n        showGridLines: true\n      };\n      ws['!cols'] = configuration.widths.map(function (each) {\n        return {\n          wpx: each\n        };\n      });\n\n      /* add worksheet to workbook */\n      wb.SheetNames.push(ws_name);\n      wb.Sheets[ws_name] = ws;\n      var wbout = XLSX.write(wb, wopts);\n      function s2ab(s) {\n        var buf = new ArrayBuffer(s.length);\n        var view = new Uint8Array(buf);\n        for (var i = 0; i !== s.length; ++i) view[i] = s.charCodeAt(i) & 0xFF;\n        return buf;\n      }\n      FileSaver.saveAs(new Blob([s2ab(wbout)], {\n        type: 'application/octet-stream'\n      }), configuration.exportname + '.xlsx');\n      if (configuration.on_finished) configuration.on_finished();\n    });\n  }\n  return {\n    'make_xlsx': make_xlsx\n  };\n}();\n__webpack_require__.g.$exporter = $exporter;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ZZXNwbGFuL3Jlc291cmNlcy9yZWFjdGpzLWNvbXBvbmVudHMvZXhwb3J0ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdENvbXBvbmVudHNfLy4vWWVzcGxhbi9yZXNvdXJjZXMvcmVhY3Rqcy1jb21wb25lbnRzL2V4cG9ydGVyLmpzP2I2MjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlLCBmdW5jLW5hbWVzLCBuby1iaXR3aXNlLCBuby1sb29wLWZ1bmMsIG5vLXVudXNlZC12YXJzLCBuby12YXIsIG9iamVjdC1zaG9ydGhhbmQsIHByZWZlci10ZW1wbGF0ZSwgdmFycy1vbi10b3AgLS0gVE9ETzogZHJvcCB0aGVzZSBkaXNhYmxlbWVudHMgKGFkZGVkIGFzIGEgcHJvdmlzaW9uIGZvciBcImdyYW5kZmF0aGVyZWRcIiBjb2RlIHRoYXQgd2FzIHByZXZpb3VzbHkgaW5jbHVkZWQgdGhyb3VnaCBndWxwKSAqL1xuXG5pbXBvcnQgY29udmVydERhdGF2aWV3VmFsdWVUb0V4Y2VsIGZyb20gJy4vY29tbW9uL2NvbnZlcnREYXRhdmlld1ZhbHVlVG9FeGNlbCc7XG5cbnZhciAkZXhwb3J0ZXIgPSAoZnVuY3Rpb24oKSB7XG4gIC8qIEdlbmVyYXRlIGFuIHhsc3ggZmlsZVxuICAgIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdDpcbiAgICB1cmwgICAgICAgICAgICAgOiBkYXRhIHNvdXJjZVxuICAgIGhlYWRlcnMgICAgICAgICA6IGFycmF5IG9mIGFycmF5cyAob25lIGZvciBlYWNoIGhlYWRlcikgd2l0aCBoZWFkZXIgbmFtZXMgKHN0cmluZ3MpXG4gICAgd2lkdGhzICAgICAgICAgIDogYXJyYXkgb2YgY29sdW1uIHdpZHRocyAoaW50ZWdlcnMpXG4gICAgZXhwb3J0bmFtZSAgICAgIDogZmlsZSBuYW1lXG4gICAgZXhwb3J0c2hlZXRuYW1lIDogc2hlZXQgbmFtZVxuICAgIGV4Y2VsZGF0ZWZvcm1hdHM6IG9iamVjdCB3aXRoIEV4Y2VsIGZvcm1hdCBzdHJpbmcgZm9yICdkYXRlJyBhbmQgJ2RhdGV0aW1lJ1xuICAgIG9uX2ZpbmlzaGVkICAgICA6IGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgZ2VuZXJhdGlvbiBoYXMgY29tcGxldGVkICovXG4gIGZ1bmN0aW9uIG1ha2VfeGxzeChjb25maWd1cmF0aW9uKSB7XG4gICAgZnVuY3Rpb24gc2hlZXRfZnJvbV9hcnJheV9vZl9hcnJheXMoaGVhZGVycywgYm9keURhdGEpIHtcbiAgICAgIHZhciBkYXRhID0gaGVhZGVycy5jb25jYXQoYm9keURhdGEpO1xuICAgICAgdmFyIHdzID0ge307XG4gICAgICBmb3IgKHZhciBSID0gMDsgUiAhPT0gZGF0YS5sZW5ndGg7ICsrUikge1xuICAgICAgICBmb3IgKHZhciBDID0gMDsgQyAhPT0gZGF0YVtSXS5sZW5ndGg7ICsrQykge1xuICAgICAgICAgIGNvbnZlcnREYXRhdmlld1ZhbHVlVG9FeGNlbChkYXRhW1JdW0NdLCBudWxsLCBmdW5jdGlvbihleGNlbENlbGxWYWx1ZSwgZXhjZWxOdW1iZXJGb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0geyB9O1xuICAgICAgICAgICAgaWYgKGV4Y2VsQ2VsbFZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICBjZWxsLnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2VsbC52ID0gZXhjZWxDZWxsVmFsdWU7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgZXhjZWxDZWxsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnbic7XG4gICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzogcmV0dXJuICdiJztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiAncyc7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNhc2UgZm9yICdleGNlbENlbGxWYWx1ZSdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4Y2VsTnVtYmVyRm9ybWF0KVxuICAgICAgICAgICAgICBjZWxsLnogPSBleGNlbE51bWJlckZvcm1hdDtcbiAgICAgICAgICAgIC8vIEFwcGx5IHNwZWNpZmljIGZvcm1hdCB0byB0aGUgaGVhZGVyIHJvd1xuICAgICAgICAgICAgaWYgKFIgPT09IDApIHtcbiAgICAgICAgICAgICAgY2VsbC5zID0ge1xuICAgICAgICAgICAgICAgIGZpbGw6IHsgZmdDb2xvcjogeyByZ2I6ICcwMEZGQ0MwMCcgfSB9LFxuICAgICAgICAgICAgICAgIGZvbnQ6IHsgYm9sZDogdHJ1ZSB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2VsbF9yZWYgPSBYTFNYLnV0aWxzLmVuY29kZV9jZWxsKHtcbiAgICAgICAgICAgICAgYzogQyxcbiAgICAgICAgICAgICAgcjogUlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3c1tjZWxsX3JlZl0gPSBjZWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcmFuZ2UgPSB7IHM6IHsgYzogMCwgcjogMCB9LCBlOiB7IGM6IGhlYWRlcnNbMF0ubGVuZ3RoIC0gMSwgcjogZGF0YS5sZW5ndGggLSAxIH0gfTtcbiAgICAgIHdzWychcmVmJ10gPSBYTFNYLnV0aWxzLmVuY29kZV9yYW5nZShyYW5nZSk7XG4gICAgICByZXR1cm4gd3M7XG4gICAgfVxuXG4gICAgJC5nZXRKU09OKGNvbmZpZ3VyYXRpb24udXJsKVxuICAgICAgLmRvbmUoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgd3NfbmFtZSA9IGNvbmZpZ3VyYXRpb24uZXhwb3J0c2hlZXRuYW1lO1xuXG4gICAgICAgIGZ1bmN0aW9uIFdvcmtib29rKCkge1xuICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXb3JrYm9vaykpIHJldHVybiBuZXcgV29ya2Jvb2soKTtcbiAgICAgICAgICB0aGlzLlNoZWV0TmFtZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLlNoZWV0cyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdiID0gbmV3IFdvcmtib29rKCk7XG4gICAgICAgIHZhciB3cyA9IHNoZWV0X2Zyb21fYXJyYXlfb2ZfYXJyYXlzKGNvbmZpZ3VyYXRpb24uaGVhZGVycywgZGF0YSk7XG4gICAgICAgIHZhciBkZWZhdWx0Q2VsbFN0eWxlID0ge2ZvbnQ6IHtuYW1lOiAnQ2FsaWJyaScsIHN6OiAxMSwgY29sb3I6ICdGRjAwRkY4OCd9LCBmaWxsOiB7ZmdDb2xvcjoge3JnYjogJ0ZGRkZBQTAwJ319fTtcbiAgICAgICAgdmFyIHdvcHRzID0ge2Jvb2tUeXBlOiAneGxzeCcsIGJvb2tTU1Q6IGZhbHNlLCB0eXBlOiAnYmluYXJ5JywgZGVmYXVsdENlbGxTdHlsZTogZGVmYXVsdENlbGxTdHlsZSwgc2hvd0dyaWRMaW5lczogdHJ1ZX07XG5cbiAgICAgICAgd3NbJyFjb2xzJ10gPSBjb25maWd1cmF0aW9uLndpZHRocy5tYXAoZnVuY3Rpb24oZWFjaCkgeyByZXR1cm4geyB3cHg6IGVhY2ggfTsgfSk7XG5cbiAgICAgICAgLyogYWRkIHdvcmtzaGVldCB0byB3b3JrYm9vayAqL1xuICAgICAgICB3Yi5TaGVldE5hbWVzLnB1c2god3NfbmFtZSk7XG4gICAgICAgIHdiLlNoZWV0c1t3c19uYW1lXSA9IHdzO1xuICAgICAgICB2YXIgd2JvdXQgPSBYTFNYLndyaXRlKHdiLCB3b3B0cyk7XG5cbiAgICAgICAgZnVuY3Rpb24gczJhYihzKSB7XG4gICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihzLmxlbmd0aCk7XG4gICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBzLmxlbmd0aDsgKytpKSB2aWV3W2ldID0gcy5jaGFyQ29kZUF0KGkpICYgMHhGRjtcbiAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG5cbiAgICAgICAgRmlsZVNhdmVyLnNhdmVBcyhuZXcgQmxvYihbczJhYih3Ym91dCldLCB7XG4gICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcbiAgICAgICAgfSksIGNvbmZpZ3VyYXRpb24uZXhwb3J0bmFtZSArICcueGxzeCcpO1xuXG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uLm9uX2ZpbmlzaGVkKSBjb25maWd1cmF0aW9uLm9uX2ZpbmlzaGVkKCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgJ21ha2VfeGxzeCc6IG1ha2VfeGxzeCxcbiAgfTtcbn0pKCk7XG5cbmdsb2JhbC4kZXhwb3J0ZXIgPSAkZXhwb3J0ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./Yesplan/resources/reactjs-components/exporter.js\n");

/***/ }),

/***/ "./Yesplan/resources/reactjs-components/common/addhttp.ts":
/***/ (function(__unused_webpack_module, exports) {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nfunction addhttp(string) {\n  if (string.match(/(http|ftp|https|file):\\/\\/.*/)) return \"\".concat(string);else return \"http://\".concat(string);\n}\nexports[\"default\"] = addhttp;\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ZZXNwbGFuL3Jlc291cmNlcy9yZWFjdGpzLWNvbXBvbmVudHMvY29tbW9uL2FkZGh0dHAudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBR0E7QUFKQTtBQUlBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3RDb21wb25lbnRzXy8uL1llc3BsYW4vcmVzb3VyY2VzL3JlYWN0anMtY29tcG9uZW50cy9jb21tb24vYWRkaHR0cC50cz84YmRhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZGh0dHAoc3RyaW5nOiBzdHJpbmcpIHtcbiAgaWYoc3RyaW5nLm1hdGNoKC8oaHR0cHxmdHB8aHR0cHN8ZmlsZSk6XFwvXFwvLiovKSlcbiAgICByZXR1cm4gYCR7c3RyaW5nfWA7XG4gIGVsc2UgcmV0dXJuIGBodHRwOi8vJHtzdHJpbmd9YDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./Yesplan/resources/reactjs-components/common/addhttp.ts\n");

/***/ }),

/***/ "./Yesplan/resources/reactjs-components/common/convertDataviewValueToExcel.ts":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n\n/* eslint-disable func-names, no-underscore-dangle, @typescript-eslint/no-use-before-define, no-var, prefer-template, vars-on-top -- TODO: drop these disablements (added as a provision for \"grandfathered\" code that was previously included through gulp) */\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.excelDateTimeNumberFromDataviewDateTimeLocalToInstallation = exports.excelDateTimeNumberFromDataviewDate = exports.excelDateTimeNumber = void 0;\nvar addhttp_1 = __webpack_require__(\"./Yesplan/resources/reactjs-components/common/addhttp.ts\");\nexports.excelDateTimeNumber = function () {\n  var utc = function utc(year, month, day, hour, minute, second) {\n    return Date.UTC(year, month - 1, day, hour, minute, second, 0);\n  };\n  var utcExcelBase = utc(1899, 12, 31, 0, 0, 0);\n  return function (year, month, day, hour, minute, second) {\n    var utcArguments = utc(year, month, day, hour, minute, second);\n    var offset = (utcArguments - utcExcelBase) / (24 * 60 * 60 * 1000);\n    return offset + (year === 1900 && month <= 2 ? 0 : 1);\n  };\n}();\nfunction excelDateTimeNumberFromDataviewDate(dateString) {\n  var _exports;\n  var regexp = /^([1-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$/;\n  var match = dateString.match(regexp);\n  if (match === null) throw new Error(\"Could not parse \\u201C\".concat(dateString, \"\\u201D as a dataview date value\"));\n  var numbers = match.slice(1).map(function (value) {\n    return parseInt(value, 10);\n  });\n  return (_exports = exports).excelDateTimeNumber.apply(_exports, _toConsumableArray(numbers).concat([0, 0, 0]));\n}\nexports.excelDateTimeNumberFromDataviewDate = excelDateTimeNumberFromDataviewDate;\nfunction excelDateTimeNumberFromDataviewDateTimeLocalToInstallation(dateTimeString) {\n  var _exports2;\n  var regexp = /^([1-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])T([0-9][0-9]):([0-9][0-9]):([0-9][0-9]).[0-9][0-9]:[0-9][0-9]$/;\n  var match = dateTimeString.match(regexp);\n  if (match === null) throw new Error(\"Could not parse \\u201C\".concat(dateTimeString, \"\\u201D as a dataview date-time value\"));\n  var numbers = match.slice(1).map(function (value) {\n    return parseInt(value, 10);\n  });\n  return (_exports2 = exports).excelDateTimeNumber.apply(_exports2, _toConsumableArray(numbers));\n}\nexports.excelDateTimeNumberFromDataviewDateTimeLocalToInstallation = excelDateTimeNumberFromDataviewDateTimeLocalToInstallation;\nfunction convertDataviewObjectToExcelStringCellValue(object) {\n  switch (object._type) {\n    case 'NPLinkAttachment':\n      return addhttp_1.default(object.url.value);\n    case 'NPTimeTableEntry':\n      return object.startTime.value + ' ' + object.description + (object.tag && object.tag !== '' ? ' (' + object.tag + ')' : '');\n    case 'NPTimeTableEntryStartStop':\n      return object.start.value + (object.stop && object.stop.value ? ' - ' + object.stop.value : '');\n    case 'NPHistoryEntry':\n      return object.description;\n    case 'NPConflict':\n      return object.description;\n    case 'NPContactInformation':\n      return object.info;\n    case 'NPContactAddressPerType':\n      return object.addresstype + ': ' + object.address || object.country;\n    case 'NPResourceUsePriceCell':\n    case 'NPPriceCell':\n      return convertTypeTaggedDataviewValueToExcelCellValue(object.price);\n    case 'NPEventPriceLine':\n      return object.description;\n    case 'NPCompositeEventPriceLine':\n      return object.description;\n    case 'NPResourceGroupPriceLine':\n      return object.description;\n    case 'NPResourceUsePriceLine':\n      return object.description;\n    case 'NPResourceInstanceUseGroupPriceLine':\n      return object.description;\n    case 'NPVatPerPercentage':\n      return convertTypeTaggedDataviewValueToExcelCellValue(object.vatRate) + ': ' + convertTypeTaggedDataviewValueToExcelCellValue(object.vat);\n    case 'NPNetPricePerPercentage':\n      return convertTypeTaggedDataviewValueToExcelCellValue(object.vatRate) + ': ' + convertTypeTaggedDataviewValueToExcelCellValue(object.netPrice);\n    case 'NPGrossPricePerPercentage':\n      return convertTypeTaggedDataviewValueToExcelCellValue(object.vatRate) + ': ' + convertTypeTaggedDataviewValueToExcelCellValue(object.grossPrice);\n    case 'NPCostRateWithAmount':\n    case 'NPAmountPerDayPart':\n    case 'NPDayPartCostRate':\n      return object.description;\n    case 'NPUrl':\n    case 'NPEmailAddress':\n      return object.value;\n    case 'NPResourceGroupPricing':\n      return object.name + ': ' + convertDataviewObjectToExcelStringCellValue(object.pricing);\n    case 'NPBilledUnits':\n      return convertTypeTaggedDataviewValueToExcelCellValue(object.number) + ' ' + object.units;\n    default:\n      if (object.name) return object.name;\n      return '' + object;\n  }\n}\nfunction excelPercentageNumberFormat(dataViewValue, alwaysShowSign) {\n  var defaultFormat = alwaysShowSign ? '+0.00%;-0.00%' : '0.00%';\n  if (!dataViewValue.value) {\n    return defaultFormat;\n  }\n  var percentagePrecision = dataViewValue.value.precision;\n  if (percentagePrecision === null || percentagePrecision === undefined) {\n    return defaultFormat;\n  }\n  if (percentagePrecision === 0) return alwaysShowSign ? '+0%' : '0%';\n  var percentagePrecisionString = '0'.repeat(percentagePrecision);\n  if (alwaysShowSign) {\n    return '+0.' + percentagePrecisionString + '%;-0.' + percentagePrecisionString + '%';\n  } else {\n    return '0.' + '0'.repeat(percentagePrecision) + '%';\n  }\n}\nfunction excelNumberFormatForDataviewType(typeSymbol, dataViewValue) {\n  switch (typeSymbol) {\n    case 'date':\n      return 'dd-mm-yyyy';\n    case 'dateOrTime':\n    case 'dateAndTime':\n      return 'dd-mm-yyyy hh:mm';\n    case 'time':\n      return 'hh:mm';\n    case 'duration':\n      return '[hh]:mm';\n    case 'percentage':\n      return excelPercentageNumberFormat(dataViewValue, false);\n    case 'relativePercentage':\n      return excelPercentageNumberFormat(dataViewValue, true);\n    case 'number':\n    case 'price':\n      var numberPrecision = dataViewValue && dataViewValue.value ? dataViewValue.value.precision : null;\n      if (numberPrecision === 0) return '0';\n      return numberPrecision === null || numberPrecision === undefined ? typeSymbol === 'price' ? '@' : 'General' : '0.' + '0'.repeat(numberPrecision);\n    case 'boolean':\n    case 'selected':\n      return 'General';\n    case 'string':\n    default:\n      return '@';\n  }\n}\nfunction excelNumberFormatForPossibleDataviewTypes(typeSymbols, dataviewValue) {\n  if (typeSymbols.length === 0) return 'General';\n  var numberFormat = excelNumberFormatForDataviewType(typeSymbols[0], dataviewValue);\n  for (var i = 1; i < typeSymbols.length; i++) {\n    if (excelNumberFormatForDataviewType(typeSymbols[i], dataviewValue) !== numberFormat) return 'General';\n  }\n  return numberFormat;\n}\nfunction convertTypeTaggedDataviewValueToExcelCellValue(dataviewValue) {\n  switch (dataviewValue._type) {\n    case 'date':\n      return excelDateTimeNumberFromDataviewDate(dataviewValue.value);\n    case 'dateAndTime':\n      return excelDateTimeNumberFromDataviewDateTimeLocalToInstallation(dataviewValue.value);\n    case 'time':\n    case 'duration':\n      var timeParts = dataviewValue.value.split(':');\n      return (parseInt(timeParts[0], 10) + parseInt(timeParts[1], 10) / 60) / 24;\n    case 'percentage':\n    case 'relativePercentage':\n      return dataviewValue.value === null ? dataviewValue.value : dataviewValue.value.number === '' ? '' : Number(dataviewValue.value.number) / 100;\n    case 'number':\n    case 'price':\n      return dataviewValue.value.number === '' ? '' : Number(dataviewValue.value.number);\n    default:\n      return convertDataviewObjectToExcelStringCellValue(dataviewValue);\n  }\n}\nfunction convertDataviewValueToExcel(dataviewValue, possibleDataviewTypes, consumer) {\n  switch (_typeof(dataviewValue)) {\n    case 'string':\n      if (dataviewValue.length === 0) consumer('', possibleDataviewTypes ? excelNumberFormatForPossibleDataviewTypes(possibleDataviewTypes, dataviewValue) : 'General');else consumer(dataviewValue, excelNumberFormatForDataviewType('string', dataviewValue));\n      break;\n    case 'boolean':\n      consumer(dataviewValue, excelNumberFormatForDataviewType('boolean', dataviewValue));\n      break;\n    case 'number':\n      consumer(dataviewValue, excelNumberFormatForDataviewType('number', dataviewValue));\n      break;\n    case 'object':\n      if (dataviewValue !== null) {\n        if (Array.isArray(dataviewValue)) {\n          var convertedElements = [];\n          dataviewValue.forEach(function (arrayElement, index) {\n            convertDataviewValueToExcel(arrayElement, null, function (excelCellValue) {\n              convertedElements[index] = excelCellValue;\n            });\n          });\n          consumer(convertedElements.join(', '), '@');\n        } else {\n          consumer(convertTypeTaggedDataviewValueToExcelCellValue(dataviewValue), excelNumberFormatForDataviewType(dataviewValue._type, dataviewValue));\n        }\n      } else {\n        throw new Error('Unexpected null value in excel export cell');\n      }\n      ;\n      break;\n    default:\n      throw new Error('Unexpected type of dataview value: ' + dataviewValue);\n  }\n}\n;\nexports[\"default\"] = convertDataviewValueToExcel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ZZXNwbGFuL3Jlc291cmNlcy9yZWFjdGpzLWNvbXBvbmVudHMvY29tbW9uL2NvbnZlcnREYXRhdmlld1ZhbHVlVG9FeGNlbC50cy5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7O0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdENvbXBvbmVudHNfLy4vWWVzcGxhbi9yZXNvdXJjZXMvcmVhY3Rqcy1jb21wb25lbnRzL2NvbW1vbi9jb252ZXJ0RGF0YXZpZXdWYWx1ZVRvRXhjZWwudHM/M2M3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBmdW5jLW5hbWVzLCBuby11bmRlcnNjb3JlLWRhbmdsZSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lLCBuby12YXIsIHByZWZlci10ZW1wbGF0ZSwgdmFycy1vbi10b3AgLS0gVE9ETzogZHJvcCB0aGVzZSBkaXNhYmxlbWVudHMgKGFkZGVkIGFzIGEgcHJvdmlzaW9uIGZvciBcImdyYW5kZmF0aGVyZWRcIiBjb2RlIHRoYXQgd2FzIHByZXZpb3VzbHkgaW5jbHVkZWQgdGhyb3VnaCBndWxwKSAqL1xuXG5pbXBvcnQgYWRkaHR0cCBmcm9tIFwiLi9hZGRodHRwXCI7XG5cbmV4cG9ydCBjb25zdCBleGNlbERhdGVUaW1lTnVtYmVyID0gKCgpID0+IHtcbiAgY29uc3QgdXRjID0gKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIsIGhvdXI6IG51bWJlciwgbWludXRlOiBudW1iZXIsIHNlY29uZDogbnVtYmVyKSA9PlxuICAgIERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgMCk7XG4gIGNvbnN0IHV0Y0V4Y2VsQmFzZSA9IHV0YygxODk5LCAxMiwgMzEsIDAsIDAsIDApO1xuICByZXR1cm4gKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIsIGhvdXI6IG51bWJlciwgbWludXRlOiBudW1iZXIsIHNlY29uZDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgdXRjQXJndW1lbnRzID0gdXRjKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKTtcbiAgICBjb25zdCBvZmZzZXQgPSAodXRjQXJndW1lbnRzIC0gdXRjRXhjZWxCYXNlKSAvICgyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgKCh5ZWFyID09PSAxOTAwKSAmJiAobW9udGggPD0gMikgPyAwIDogMSk7XG4gIH1cbn0pKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBleGNlbERhdGVUaW1lTnVtYmVyRnJvbURhdGF2aWV3RGF0ZShkYXRlU3RyaW5nOiBzdHJpbmcpIHtcbiAgY29uc3QgcmVnZXhwID0gL14oWzEtOV1bMC05XVswLTldWzAtOV0pLShbMC05XVswLTldKS0oWzAtOV1bMC05XSkkLztcbiAgY29uc3QgbWF0Y2ggPSBkYXRlU3RyaW5nLm1hdGNoKHJlZ2V4cCk7XG4gIGlmIChtYXRjaCA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSDigJwke2RhdGVTdHJpbmd94oCdIGFzIGEgZGF0YXZpZXcgZGF0ZSB2YWx1ZWApO1xuICBjb25zdCBudW1iZXJzID0gbWF0Y2guc2xpY2UoMSkubWFwKCh2YWx1ZSkgPT4gcGFyc2VJbnQodmFsdWUsIDEwKSkgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICByZXR1cm4gZXhjZWxEYXRlVGltZU51bWJlciguLi5udW1iZXJzLCAwLCAwLCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4Y2VsRGF0ZVRpbWVOdW1iZXJGcm9tRGF0YXZpZXdEYXRlVGltZUxvY2FsVG9JbnN0YWxsYXRpb24oZGF0ZVRpbWVTdHJpbmc6IHN0cmluZykge1xuICBjb25zdCByZWdleHAgPSAvXihbMS05XVswLTldWzAtOV1bMC05XSktKFswLTldWzAtOV0pLShbMC05XVswLTldKVQoWzAtOV1bMC05XSk6KFswLTldWzAtOV0pOihbMC05XVswLTldKS5bMC05XVswLTldOlswLTldWzAtOV0kLztcbiAgY29uc3QgbWF0Y2ggPSBkYXRlVGltZVN0cmluZy5tYXRjaChyZWdleHApO1xuICBpZiAobWF0Y2ggPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2Ug4oCcJHtkYXRlVGltZVN0cmluZ33igJ0gYXMgYSBkYXRhdmlldyBkYXRlLXRpbWUgdmFsdWVgKTtcbiAgY29uc3QgbnVtYmVycyA9IG1hdGNoLnNsaWNlKDEpLm1hcCgodmFsdWUpID0+IHBhcnNlSW50KHZhbHVlLCAxMCkpIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgcmV0dXJuIGV4Y2VsRGF0ZVRpbWVOdW1iZXIoLi4ubnVtYmVycyk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnREYXRhdmlld09iamVjdFRvRXhjZWxTdHJpbmdDZWxsVmFsdWUob2JqZWN0KSB7XG4gIHN3aXRjaCAob2JqZWN0Ll90eXBlKSB7XG4gICAgY2FzZSAnTlBMaW5rQXR0YWNobWVudCc6XG4gICAgICByZXR1cm4gYWRkaHR0cChvYmplY3QudXJsLnZhbHVlKTtcbiAgICBjYXNlICdOUFRpbWVUYWJsZUVudHJ5JzpcbiAgICAgIHJldHVybiBvYmplY3Quc3RhcnRUaW1lLnZhbHVlICsgJyAnICsgb2JqZWN0LmRlc2NyaXB0aW9uICsgKG9iamVjdC50YWcgJiYgb2JqZWN0LnRhZyAhPT0gJycgPyAnICgnICsgb2JqZWN0LnRhZyArICcpJyA6ICcnKTtcbiAgICBjYXNlICdOUFRpbWVUYWJsZUVudHJ5U3RhcnRTdG9wJzpcbiAgICAgIHJldHVybiBvYmplY3Quc3RhcnQudmFsdWUgKyAob2JqZWN0LnN0b3AgJiYgb2JqZWN0LnN0b3AudmFsdWUgPyAoJyAtICcgKyBvYmplY3Quc3RvcC52YWx1ZSk6ICcnKTtcbiAgICBjYXNlICdOUEhpc3RvcnlFbnRyeSc6XG4gICAgICByZXR1cm4gb2JqZWN0LmRlc2NyaXB0aW9uO1xuICAgIGNhc2UgJ05QQ29uZmxpY3QnOlxuICAgICAgcmV0dXJuIG9iamVjdC5kZXNjcmlwdGlvbjtcbiAgICBjYXNlICdOUENvbnRhY3RJbmZvcm1hdGlvbic6XG4gICAgICByZXR1cm4gb2JqZWN0LmluZm87XG4gICAgY2FzZSAnTlBDb250YWN0QWRkcmVzc1BlclR5cGUnOlxuICAgICAgcmV0dXJuIG9iamVjdC5hZGRyZXNzdHlwZSArICc6ICcgKyBvYmplY3QuYWRkcmVzcyB8fCBvYmplY3QuY291bnRyeTtcbiAgY2FzZSAnTlBSZXNvdXJjZVVzZVByaWNlQ2VsbCc6XG4gICAgY2FzZSAnTlBQcmljZUNlbGwnOlxuICAgICAgcmV0dXJuIGNvbnZlcnRUeXBlVGFnZ2VkRGF0YXZpZXdWYWx1ZVRvRXhjZWxDZWxsVmFsdWUob2JqZWN0LnByaWNlKTtcbiAgICBjYXNlICdOUEV2ZW50UHJpY2VMaW5lJzpcbiAgICAgIHJldHVybiBvYmplY3QuZGVzY3JpcHRpb247XG4gICAgY2FzZSAnTlBDb21wb3NpdGVFdmVudFByaWNlTGluZSc6XG4gICAgICByZXR1cm4gb2JqZWN0LmRlc2NyaXB0aW9uO1xuICAgIGNhc2UgJ05QUmVzb3VyY2VHcm91cFByaWNlTGluZSc6XG4gICAgICByZXR1cm4gb2JqZWN0LmRlc2NyaXB0aW9uO1xuICAgIGNhc2UgJ05QUmVzb3VyY2VVc2VQcmljZUxpbmUnOlxuICAgICAgcmV0dXJuIG9iamVjdC5kZXNjcmlwdGlvbjtcbiAgICBjYXNlICdOUFJlc291cmNlSW5zdGFuY2VVc2VHcm91cFByaWNlTGluZSc6XG4gICAgICByZXR1cm4gb2JqZWN0LmRlc2NyaXB0aW9uO1xuICAgIGNhc2UgJ05QVmF0UGVyUGVyY2VudGFnZSc6XG4gICAgICByZXR1cm4gY29udmVydFR5cGVUYWdnZWREYXRhdmlld1ZhbHVlVG9FeGNlbENlbGxWYWx1ZShvYmplY3QudmF0UmF0ZSkgKyAnOiAnICsgY29udmVydFR5cGVUYWdnZWREYXRhdmlld1ZhbHVlVG9FeGNlbENlbGxWYWx1ZShvYmplY3QudmF0KTtcbiAgICBjYXNlICdOUE5ldFByaWNlUGVyUGVyY2VudGFnZSc6XG4gICAgICByZXR1cm4gY29udmVydFR5cGVUYWdnZWREYXRhdmlld1ZhbHVlVG9FeGNlbENlbGxWYWx1ZShvYmplY3QudmF0UmF0ZSkgKyAnOiAnICsgY29udmVydFR5cGVUYWdnZWREYXRhdmlld1ZhbHVlVG9FeGNlbENlbGxWYWx1ZShvYmplY3QubmV0UHJpY2UpO1xuICAgIGNhc2UgJ05QR3Jvc3NQcmljZVBlclBlcmNlbnRhZ2UnOlxuICAgICAgcmV0dXJuIGNvbnZlcnRUeXBlVGFnZ2VkRGF0YXZpZXdWYWx1ZVRvRXhjZWxDZWxsVmFsdWUob2JqZWN0LnZhdFJhdGUpICsgJzogJyArIGNvbnZlcnRUeXBlVGFnZ2VkRGF0YXZpZXdWYWx1ZVRvRXhjZWxDZWxsVmFsdWUob2JqZWN0Lmdyb3NzUHJpY2UpO1xuICAgIGNhc2UgJ05QQ29zdFJhdGVXaXRoQW1vdW50JzpcbiAgICBjYXNlICdOUEFtb3VudFBlckRheVBhcnQnOlxuICAgIGNhc2UgJ05QRGF5UGFydENvc3RSYXRlJzpcbiAgICAgIHJldHVybiBvYmplY3QuZGVzY3JpcHRpb247XG4gICAgY2FzZSAnTlBVcmwnOlxuICAgIGNhc2UgJ05QRW1haWxBZGRyZXNzJzpcbiAgICAgIHJldHVybiBvYmplY3QudmFsdWU7XG4gICAgY2FzZSAnTlBSZXNvdXJjZUdyb3VwUHJpY2luZyc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgKyAnOiAnICsgY29udmVydERhdGF2aWV3T2JqZWN0VG9FeGNlbFN0cmluZ0NlbGxWYWx1ZShvYmplY3QucHJpY2luZyk7XG4gICAgY2FzZSAnTlBCaWxsZWRVbml0cyc6XG4gICAgICByZXR1cm4gY29udmVydFR5cGVUYWdnZWREYXRhdmlld1ZhbHVlVG9FeGNlbENlbGxWYWx1ZShvYmplY3QubnVtYmVyKSArICcgJyArIG9iamVjdC51bml0cztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKG9iamVjdC5uYW1lKVxuICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWU7XG4gICAgICByZXR1cm4gJycgKyBvYmplY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhjZWxQZXJjZW50YWdlTnVtYmVyRm9ybWF0KGRhdGFWaWV3VmFsdWUsIGFsd2F5c1Nob3dTaWduKSB7XG4gIHZhciBkZWZhdWx0Rm9ybWF0ID0gYWx3YXlzU2hvd1NpZ24gPyAnKzAuMDAlOy0wLjAwJScgOiAnMC4wMCUnO1xuICBpZiAoIWRhdGFWaWV3VmFsdWUudmFsdWUpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZvcm1hdDtcbiAgfVxuICB2YXIgcGVyY2VudGFnZVByZWNpc2lvbiA9IGRhdGFWaWV3VmFsdWUudmFsdWUucHJlY2lzaW9uO1xuICBpZiAocGVyY2VudGFnZVByZWNpc2lvbiA9PT0gbnVsbCB8fCBwZXJjZW50YWdlUHJlY2lzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZvcm1hdDtcbiAgfVxuICBpZiAocGVyY2VudGFnZVByZWNpc2lvbiA9PT0gMCkgcmV0dXJuIChhbHdheXNTaG93U2lnbiA/ICcrMCUnIDogJzAlJyk7XG4gIHZhciBwZXJjZW50YWdlUHJlY2lzaW9uU3RyaW5nID0gJzAnLnJlcGVhdChwZXJjZW50YWdlUHJlY2lzaW9uKTtcbiAgaWYgKGFsd2F5c1Nob3dTaWduKSB7XG4gICAgcmV0dXJuICcrMC4nICsgcGVyY2VudGFnZVByZWNpc2lvblN0cmluZyArICclOy0wLicgKyBwZXJjZW50YWdlUHJlY2lzaW9uU3RyaW5nICsnJSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcwLicgKyAnMCcucmVwZWF0KHBlcmNlbnRhZ2VQcmVjaXNpb24pICsgJyUnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4Y2VsTnVtYmVyRm9ybWF0Rm9yRGF0YXZpZXdUeXBlKHR5cGVTeW1ib2wsIGRhdGFWaWV3VmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlU3ltYm9sKSB7XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICByZXR1cm4gJ2RkLW1tLXl5eXknO1xuICAgIGNhc2UgJ2RhdGVPclRpbWUnOlxuICAgIGNhc2UgJ2RhdGVBbmRUaW1lJzpcbiAgICAgIHJldHVybiAnZGQtbW0teXl5eSBoaDptbSc7XG4gICAgY2FzZSAndGltZSc6XG4gICAgICByZXR1cm4gJ2hoOm1tJztcbiAgICBjYXNlICdkdXJhdGlvbic6XG4gICAgICByZXR1cm4gJ1toaF06bW0nO1xuICAgIGNhc2UgJ3BlcmNlbnRhZ2UnOlxuICAgICAgcmV0dXJuIGV4Y2VsUGVyY2VudGFnZU51bWJlckZvcm1hdChkYXRhVmlld1ZhbHVlLCBmYWxzZSk7XG4gICAgY2FzZSAncmVsYXRpdmVQZXJjZW50YWdlJzpcbiAgICAgIHJldHVybiBleGNlbFBlcmNlbnRhZ2VOdW1iZXJGb3JtYXQoZGF0YVZpZXdWYWx1ZSwgdHJ1ZSk7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdwcmljZSc6XG4gICAgICB2YXIgbnVtYmVyUHJlY2lzaW9uID0gZGF0YVZpZXdWYWx1ZSAmJiBkYXRhVmlld1ZhbHVlLnZhbHVlID8gZGF0YVZpZXdWYWx1ZS52YWx1ZS5wcmVjaXNpb24gOiBudWxsO1xuICAgICAgaWYgKG51bWJlclByZWNpc2lvbiA9PT0gMCkgcmV0dXJuICcwJztcbiAgICAgIHJldHVybiAobnVtYmVyUHJlY2lzaW9uID09PSBudWxsIHx8IG51bWJlclByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICA/ICgodHlwZVN5bWJvbCA9PT0gJ3ByaWNlJykgPyAnQCcgOiAnR2VuZXJhbCcpXG4gICAgICAgIDogJzAuJyArICcwJy5yZXBlYXQobnVtYmVyUHJlY2lzaW9uKTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICByZXR1cm4gJ0dlbmVyYWwnO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnQCc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhjZWxOdW1iZXJGb3JtYXRGb3JQb3NzaWJsZURhdGF2aWV3VHlwZXModHlwZVN5bWJvbHMsIGRhdGF2aWV3VmFsdWUpIHtcbiAgaWYgKHR5cGVTeW1ib2xzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdHZW5lcmFsJztcbiAgdmFyIG51bWJlckZvcm1hdCA9IGV4Y2VsTnVtYmVyRm9ybWF0Rm9yRGF0YXZpZXdUeXBlKHR5cGVTeW1ib2xzWzBdLCBkYXRhdmlld1ZhbHVlKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0eXBlU3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChleGNlbE51bWJlckZvcm1hdEZvckRhdGF2aWV3VHlwZSh0eXBlU3ltYm9sc1tpXSwgZGF0YXZpZXdWYWx1ZSkgIT09IG51bWJlckZvcm1hdClcbiAgICAgIHJldHVybiAnR2VuZXJhbCc7XG4gIH1cbiAgcmV0dXJuIG51bWJlckZvcm1hdDtcbn1cblxuZnVuY3Rpb24gY29udmVydFR5cGVUYWdnZWREYXRhdmlld1ZhbHVlVG9FeGNlbENlbGxWYWx1ZShkYXRhdmlld1ZhbHVlKSB7XG4gIHN3aXRjaCAoZGF0YXZpZXdWYWx1ZS5fdHlwZSkge1xuICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgcmV0dXJuIGV4Y2VsRGF0ZVRpbWVOdW1iZXJGcm9tRGF0YXZpZXdEYXRlKGRhdGF2aWV3VmFsdWUudmFsdWUpO1xuICAgIGNhc2UgJ2RhdGVBbmRUaW1lJzpcbiAgICAgIHJldHVybiBleGNlbERhdGVUaW1lTnVtYmVyRnJvbURhdGF2aWV3RGF0ZVRpbWVMb2NhbFRvSW5zdGFsbGF0aW9uKGRhdGF2aWV3VmFsdWUudmFsdWUpO1xuICAgIGNhc2UgJ3RpbWUnOlxuICAgIGNhc2UgJ2R1cmF0aW9uJzpcbiAgICAgIHZhciB0aW1lUGFydHMgPSBkYXRhdmlld1ZhbHVlLnZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICByZXR1cm4gKHBhcnNlSW50KHRpbWVQYXJ0c1swXSwgMTApICsgKHBhcnNlSW50KHRpbWVQYXJ0c1sxXSwgMTApIC8gNjApKSAvIDI0O1xuICAgIGNhc2UgJ3BlcmNlbnRhZ2UnOlxuICAgIGNhc2UgJ3JlbGF0aXZlUGVyY2VudGFnZSc6XG4gICAgICByZXR1cm4gZGF0YXZpZXdWYWx1ZS52YWx1ZSA9PT0gbnVsbCA/IGRhdGF2aWV3VmFsdWUudmFsdWUgOiAoZGF0YXZpZXdWYWx1ZS52YWx1ZS5udW1iZXIgPT09ICcnID8gJycgOiBOdW1iZXIoZGF0YXZpZXdWYWx1ZS52YWx1ZS5udW1iZXIpIC8gMTAwKTtcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3ByaWNlJzpcbiAgICAgIHJldHVybiBkYXRhdmlld1ZhbHVlLnZhbHVlLm51bWJlciA9PT0gJycgPyAnJyA6IE51bWJlcihkYXRhdmlld1ZhbHVlLnZhbHVlLm51bWJlcik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb252ZXJ0RGF0YXZpZXdPYmplY3RUb0V4Y2VsU3RyaW5nQ2VsbFZhbHVlKGRhdGF2aWV3VmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnREYXRhdmlld1ZhbHVlVG9FeGNlbChkYXRhdmlld1ZhbHVlLCBwb3NzaWJsZURhdGF2aWV3VHlwZXMsIGNvbnN1bWVyKSB7XG4gIHN3aXRjaCAodHlwZW9mIGRhdGF2aWV3VmFsdWUpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgaWYgKGRhdGF2aWV3VmFsdWUubGVuZ3RoID09PSAwKVxuICAgICAgICBjb25zdW1lcignJywgKHBvc3NpYmxlRGF0YXZpZXdUeXBlcykgPyBleGNlbE51bWJlckZvcm1hdEZvclBvc3NpYmxlRGF0YXZpZXdUeXBlcyhwb3NzaWJsZURhdGF2aWV3VHlwZXMsIGRhdGF2aWV3VmFsdWUpIDogJ0dlbmVyYWwnKTtcbiAgICAgIGVsc2VcbiAgICAgICAgY29uc3VtZXIoZGF0YXZpZXdWYWx1ZSwgZXhjZWxOdW1iZXJGb3JtYXRGb3JEYXRhdmlld1R5cGUoJ3N0cmluZycsIGRhdGF2aWV3VmFsdWUpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY29uc3VtZXIoZGF0YXZpZXdWYWx1ZSwgZXhjZWxOdW1iZXJGb3JtYXRGb3JEYXRhdmlld1R5cGUoJ2Jvb2xlYW4nLCBkYXRhdmlld1ZhbHVlKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgY29uc3VtZXIoZGF0YXZpZXdWYWx1ZSwgZXhjZWxOdW1iZXJGb3JtYXRGb3JEYXRhdmlld1R5cGUoJ251bWJlcicsIGRhdGF2aWV3VmFsdWUpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoZGF0YXZpZXdWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhdmlld1ZhbHVlKSkge1xuICAgICAgICAgIHZhciBjb252ZXJ0ZWRFbGVtZW50czogYW55W10gPSBbXTtcbiAgICAgICAgICBkYXRhdmlld1ZhbHVlLmZvckVhY2goZnVuY3Rpb24oYXJyYXlFbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgICAgY29udmVydERhdGF2aWV3VmFsdWVUb0V4Y2VsKGFycmF5RWxlbWVudCwgbnVsbCwgZnVuY3Rpb24oZXhjZWxDZWxsVmFsdWUpIHtcbiAgICAgICAgICAgICAgY29udmVydGVkRWxlbWVudHNbaW5kZXhdID0gZXhjZWxDZWxsVmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdW1lcihjb252ZXJ0ZWRFbGVtZW50cy5qb2luKCcsICcpLCAnQCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN1bWVyKGNvbnZlcnRUeXBlVGFnZ2VkRGF0YXZpZXdWYWx1ZVRvRXhjZWxDZWxsVmFsdWUoZGF0YXZpZXdWYWx1ZSksIGV4Y2VsTnVtYmVyRm9ybWF0Rm9yRGF0YXZpZXdUeXBlKGRhdGF2aWV3VmFsdWUuX3R5cGUsIGRhdGF2aWV3VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG51bGwgdmFsdWUgaW4gZXhjZWwgZXhwb3J0IGNlbGwnKTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHR5cGUgb2YgZGF0YXZpZXcgdmFsdWU6ICcgKyBkYXRhdmlld1ZhbHVlKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY29udmVydERhdGF2aWV3VmFsdWVUb0V4Y2VsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./Yesplan/resources/reactjs-components/common/convertDataviewValueToExcel.ts\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ var __webpack_exports__ = (__webpack_exec__("./Yesplan/resources/reactjs-components/exporter.js"));
/******/ ReactComponents_exporter = __webpack_exports__;
/******/ }
]);